<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
   <HEAD>
      <TITLE>My first HTML document</TITLE>
      <style rel="stylesheet" type="text/css">
body {
 font-size: 25px;
 
 margin-top: 50px;
    margin-bottom: 50px;
    margin-right: 80px;
    margin-left: 80px;
    
    padding-top: 50px;
    padding-bottom: 50px;
    padding-right: 80px;
    padding-left: 80px;
    
    line-height:1.6em
}
</style>
      <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    "HTML-CSS" : {
        availableFonts : ["STIX"],
        preferredFont : "STIX",
        webFont : "STIX-Web",
        imageFont : null
    }
});
</script>
     <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js" type="text/javascript">    
    MathJax.Hub.Config({
        HTML: ["input/TeX","output/HTML-CSS"],
        TeX: { extensions: ["AMSmath.js","AMSsymbols.js"], 
               equationNumbers: { autoNumber: "AMS" } },
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: { inlineMath: [ ['$','$'], ["<br/>(","<br/>)"] ],
                   displayMath: [ ['$$','$$'], ["<br/>[","<br/>]"] ],
                   processEscapes: true },
        "HTML-CSS": { availableFonts: ["TeX"],
                      linebreaks: { automatic: true } }
    });
</script>
   </HEAD>
   <BODY>
@Chapter.<br/>
지옥에서 온 Git : git init.<br/>
<br/>
@<br/>
version 관리 하고 싶은 folder 를 git 에게 알려주고 initialize 해야한다.<br/>
폴더에 들어가서.<br/>
git init.<br/>
<br/>
@<br/>
이렇게 하면 .git folder 가 만들어진다.<br/>
version 관리를 하면 여러 정보가 생성되는데 이 folder 에 저장된다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git : git add.<br/>
<br/>
@<br/>
vim f1.txt : vim 으로 f1.txt 편집한다.<br/>
i 를 눌러 insert mode 로 들어간다.<br/>
esc 를 눌러 default mode 로 나온다.<br/>
:wq 저장후 프로그램 종료.<br/>
<br/>
@<br/>
cat f1.txt.<br/>
file 내용 보기.<br/>
<br/>
@<br/>
git status.<br/>
untracked file : version 관리가 되는 folder 안에 존재하지만 git 이 version 관리를 위해 추적은 하고 있지 않다.<br/>
<br/>
git add f1.txt : 관리하는 목록에 추가한다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git : 버전 만들기 (commit).<br/>
<br/>
@<br/>
version 기록하는 사람을 명시하는 명령은 다음과 같다.<br/>
git config --global user.name Name.<br/>
git config --global user.email Email.<br/>
<br/>
이 정보를 포함하는 버전이 된다.<br/>
누가 작업했는지 알수 있게 된다.<br/>
<br/>
@<br/>
git commit.<br/>
vim 이 실행된다.<br/>
commit message 작성하고 commit 하면 version 이 생성된것이다.<br/>
<br/>
@<br/>
git log 로 commit message, 여러 정보를 확인.<br/>
<br/>
@<br/>
내용을 수정한다.<br/>
git status 하면 modified 를 볼 수 있다.<br/>
이 상태에서 git commit 하면 안된다.<br/>
f1.txt file 을 git add f1.txt 를 실행 시켜서 git 의 관리목록에 추가해야한다.<br/>
새로운 파일이 생겼을때 이파일의 version 관리를 최초 명령할때도 git add 를 쓰고.<br/>
버전관리가 되고 있는 파일을 수정하고 새로운 버전을 생성할 때도 git add 를 쓴다.<br/>
<br/>
git commit 실행한다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 GIT : git stage area.<br/>
<br/>
@<br/>
cp fi.txt f2.txt.<br/>
내용을 카피해서 파일을 만든다.<br/>
<br/>
git add f2.txt 를 해서 version manage 를 시작한다.<br/>
<br/>
@<br/>
내용을 수정하고 왜 바로 commit 하지 않고 먼저 add 를 하는가?.<br/>
소스 수정하다보면 commit 시기를 놓칠 때가 있다.<br/>
commit 하나는 하나의 작업을 담고있는 것이 이상적이다.<br/>
commit 시기를 놓치면 하나의 commit 이 큰 작업을 담고있게 된다.<br/>
이때 add 를 통해 commit 하고 싶은 file 만 commit 을 할수 있다.<br/>
<br/>
@<br/>
두개의 파일중 하나만 git add f1.txt 해보자.<br/>
changes to be commited 를 볼 수있다.<br/>
초록색 modified 를 볼 수 있다.<br/>
<br/>
changes not staged for commit 을 볼 수 있다.<br/>
빨간색 modified 를 볼 수 있다.<br/>
<br/>
이 상태에서 git commit 을 하면 f1.txt 를 새로운 버전에 포함된다. f2.txt 는 포함 안된다.<br/>
git add 를 통해 선택적으로 파일을 commit 할 수 있다.<br/>
<br/>
@<br/>
add 가 적용되어 commit(for a snapshot of code on a stage) 을 앞두고 있는 단계를 stage area 라고 한다.<br/>
<br/>
@<br/>
commit 이 되어 결과가 저장되는 곳은 repository 이다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 GIT : 변경 사항 확인하기 (log & diff).<br/>
<br/>
@<br/>
만들어 놓은 version 의 효용성은 크게 2가지이다.<br/>
1. version 별로 차이점을 알수있고, 과거의 특성 시점을 확인 할 수 있다.<br/>
1. 과거의 코드 상태로 돌아갈 수 있다.<br/>
<br/>
@<br/>
git log 에 option 을 줄 수 있다.<br/>
git log -p commit 끼리 code 차이점을 두 commit 정보 가운데에 줄력한다.<br/>
<br/>
+++ b/f1.txt version 4 를 가르킴.<br/>
--- a/f1.txt version 3 을 가르킴.<br/>
<br/>
+f1.txt : 2.<br/>
version 4 에서의 내용.<br/>
<br/>
-source : 2.<br/>
version 3 에서의 내용.<br/>
<br/>
--- /dev/null.<br/>
이전 version 의 내용 : 파일이 없었음.<br/>
+++ b/f2.txt.<br/>
위의 version 의 다음 version 의 내용.<br/>
<br/>
<br/>
@<br/>
git log hash-value-of-commit.<br/>
위 commit 을 포함해 이전의 모든 commit 을 보여줌.<br/>
<br/>
@<br/>
git diff hash-value-of-commit1..hash-value-of-commit2.<br/>
두 code 차이점을 보여줌.<br/>
<br/>
@<br/>
코드 수정저장하고 git diff 하면 방금 수정 내역을 보여준다.<br/>
commit 전에 last review 할때 유용하다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 GIT : 과거로 돌아가기 (reset).<br/>
<br/>
@<br/>
최신의 상태가 commit 5 일때 commit 3 상태로 돌아가고 싶다.<br/>
크게 두가지 방법이 있다.<br/>
두가지는 비슷하면서 다르다.<br/>
위험한 작업을 할때는 ls -al 치면 나오는 working directory file 을 copy 하면 좋다.<br/>
1. reset.<br/>
쉬운 방법.<br/>
5에서 3으로 가고 싶다, 즉, 5와 4를 삭제하고 싶다.<br/>
git reset hash-value-of-commit3 --hard.<br/>
하지만, git 은 정보를 왠만해서는 삭제하지않는다.<br/>
위 두 정보를 삭제한것처럼 보이지만 실제로는 남아있어서 필요하면 복구할 수 있다.<br/>
remote repository 를 이용해 협업을 할 수 있다.<br/>
내 remote repository 의 version 들을 다른 곳에 공유할수 있다.<br/>
공유한 이후에는 reset 을 하면 안된다.<br/>
reset 은 공유하기전에 내 컴퓨터에 있는 혼자 작업할 때 reset 을 써야한다.<br/>
--hard 는 위험한 방식이고 soft 와 같은 다른 option 도 있다.<br/>
1. revert.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 GIT - 스스로 공부하는 법.<br/>
<br/>
@<br/>
파일을 수정할 때마다 add, writing commit message, commit 하는것은 번거롭다.<br/>
git commit --help : commit 명령에 대한 도움말을 본다.<br/>
<br/>
git commit -a or -all.<br/>
수정하거나 삭제한 파일을 add 과정이 자동으로 진행되어 생략되고 commit message 쓰는 곳으로 간뒤 commit 하면 자동으로 stage 에 올린다.<br/>
<br/>
commit message 쓰는 창에 가는 것도 귀찮을때 다음 방법을 쓴다.<br/>
먼저 코드 내용수정.<br/>
git commit -am "commit message".<br/>
inline 에서 add, writing commit message, commit 을 한번에 한다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 GIT : 원리 - 분석도구 gistory 소개.<br/>
 .<br/>
@<br/>
pip install gistory.<br/>
<br/>
@<br/>
.git folder 가 위치하는 working directory 로 이동한다.<br/>
gistory.<br/>
port number copy 후 localhost:port 로 들어간다.<br/>
그러면, .git 내용을 탐색할 수 있다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 GIT : 원리 - git add.<br/>
<br/>
@<br/>
vim f1.txt 로 file 을 만든다.<br/>
git add f1.txt 로 git 에게 file의 version 을 track 하도록 한다.<br/>
change 를 gistory 에서 본다.<br/>
index file 이 change 되고 objects/78/98...85 added 되었다.<br/>
added 된 objects/78/98...85 file 안에는 f1.txt file 의 contents 가 담겨있다.<br/>
contents a 가 담겨있는 file 이름인 f1.txt 는 위에서 added 된 file 에 담겨있지 않다.<br/>
이 정보는 index file 안에 다음과 같은 format 으로 적히게 된다.<br/>
7898...85 f1.txt.<br/>
의미는 f1.txt file 의 contents 는 7898...85 file 에 담겨있다 이다.<br/>
<br/>
objects folder 안에 있는 file 을 object 라고 부른다.<br/>
<br/>
@<br/>
vim t2.txt 으로 another file f2.txt 를 create 한다.<br/>
git add f2.txt 을 한다.<br/>
see gistory.<br/>
index file 이 변했다.<br/>
objects/b6/80...46 이 created 되었다.<br/>
changed index file 을 열어보면 다음과 같은 format 으로 작성되어있다.<br/>
7898..85 f1.txt.<br/>
b680..46 f2.txt.<br/>
<br/>
@<br/>
create a new file f3.txt which has a copied contents from f1.txt by using cp f1.txt f3.txt.<br/>
and then, command git add f3.txt.<br/>
and then, reload gistory.<br/>
I can see 2 changed files.<br/>
one is index file, and another is objects/78/98...85 which exists before but just is updated.<br/>
try click and you can see contents a in it.<br/>
and then try explore index file and you can see the contents of it as the following format of file shown below.<br/>
7898...85 f1.txt.<br/>
b680...46 f2.txt.<br/>
7898...85 f3.txt.<br/>
<br/>
you can get the meaning of two files(f1.txt, f3.txt) indicating same object 7898...85.<br/>
<br/>
git manages as the same object file like a 7898...85 only if the contents is identical from two separate files even though the file names are different.<br/>
<br/>
no matter how you have numorous files for example 10,000 files and even if size of each file is huge, if the contents is identical in all files, git will notate only file name like f1.txt, ..., f10000.txt, those 10,000 files will indicate same object file, so that, it can prevent the probability of huge duplicate.<br/>
<br/>
everyone will get the same object name 7898...85 if each one would create a file with contents a in it.<br/>
this is done by cryptographic hash function like SHA256.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 GIT : 원리 - objects 파일명의 원리.<br/>
<br/>
@<br/>
contents 가 같으면 file 이 가리키는 object 의 이름이 같다.<br/>
<br/>
add 하면 그 파일의 contents 를 본다.<br/>
contents 가 a 이면 이 정보와 몇가지 부가적 정보를 추가해서 이것을 압축한다.<br/>
그리고 압축한 결과를 SHA1 처리하고 나온 hash value 로 folder 와 file 을 objects directory 안에 만든다.<br/>
그리고 다시 contents a 를 그 file 안에 저장한다.<br/>
그리고 index file 에 hash value(object name) 과 실제 file name f1.txt 를 connect 시켜놓는다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 GIT : 원리 - commit의 원리.<br/>
<br/>
@<br/>
content of file 뿐만 아니라 commit 정보(author, email, commit message) 도 objects 안의 file 에 들어간다.<br/>
tree 옆에 object 가 link 되어 있다.<br/>
이걸 클릭하면 해당하는 version 의 file name 과 hash value object 가 list 로 저장되어있다.<br/>
445...45 f1.txt.<br/>
231...27 f2.txt.<br/>
445...45 f3.txt.<br/>
<br/>
@<br/>
f2 의 contents 를 수정하고 version 을 한번 더 만들어본다.<br/>
git add f2.txt.<br/>
그러면, index, objects 에 영향을 준다.<br/>
<br/>
git commit.<br/>
그런다음 objects directory 를 클릭해본다.<br/>
그러면 parent 와 이것이 link 를 볼수 있다.<br/>
이것을 클릭하면 이 commit 의 이전 commit 을 볼 수 있다.<br/>
<br/>
중요한점은 첫번째 commit 과 두번째 commit 의 tree 의 hash value object link 가 다르다.<br/>
<br/>
첫번째 tree 를 클릭하면.<br/>
445...45 f1.txt.<br/>
231...27 f2.txt.<br/>
445...45 f3.txt.<br/>
을 볼수 있고 f2 의 object 를 클릭하면 z 라는 content 를 담고있는 file 이다.<br/>
<br/>
두번째 commit 의 tree 을 클릭하면 마찬가지로.<br/>
445...45 f1.txt.<br/>
231...27 f2.txt.<br/>
445...45 f3.txt.<br/>
을 볼수있고 f2 를 클릭하면 link 를 볼수있다 이 링크가 가르키는 file 은 y, z 를 저장하고 있다.<br/>
<br/>
commit 에는 주요한 정보 두가지가 있다.<br/>
1. 이전 commit (parent).<br/>
1. commit 이 일어난 시점의 working directory 에있는 file 의 이름 f1.txt 과 이 file 의 content 를 담고있는 file 의 link 정보를 담고있다.<br/>
<br/>
각각의 version 마다 서로 다른 tree 를 가르키고 있다.<br/>
이 tree 에는 file name(f1.txt) file 에 담겨있는 contents 를 담고있는 object 가 link 되어있다.<br/>
따라서, version 에 적혀있는 tree 를 통해서 version 이 만들어진 시점의 working directory 에 대한 상태를 explore 할수있다.<br/>
<br/>
In other words, 각각의 version 으로 snapshot 을 만들고 이것들을 tree data structure 를 통해서 가지고 있다.<br/>
<br/>
@<br/>
objects 안에 들어가는 file(object) 은 크게 3가지이다.<br/>
blob object : contents of file 을 저장한다.<br/>
tree object :.<br/>
34..22 f1.txt.<br/>
92..93 f2.txt.<br/>
34..22 f3.txt.<br/>
commit object : commit 에 대한 정보를 담고있는 object.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 GIT : 원리 - status의 원리.<br/>
<br/>
@<br/>
in a folder where there is nothing on the stage, when you execute git status,.<br/>
you will see the following message "nothing to commit, working directory clean".<br/>
git 은 어떻게 nothing to commit 인지 알게되는지 알아보자.<br/>
<br/>
@<br/>
index file 을 살펴봤었다.<br/>
그리고 최신 commit object 도 살펴봤다.<br/>
이 둘을 비교하면 commit 할게 있는지 없는지 알 수 있다.<br/>
index 에는 다음과 같은 내용이 담겨있다.<br/>
28..83 d1/f1.txt.<br/>
84..43 f1.txt.<br/>
58..21 f2.txt.<br/>
84..43 f3.txt.<br/>
<br/>
그리고 latest commit 을 click 해서 tree link 를 click 해 본다.<br/>
28..83 d1/f1.txt.<br/>
84..43 f1.txt.<br/>
58..21 f2.txt.<br/>
84..43 f3.txt.<br/>
이런식으로 index file 의 내용과 동일하다면 commit 할 것이 없다고 판단할 수 있다.<br/>
<br/>
@<br/>
f2.txt 를 수정했다고 가정하자.<br/>
그리고 add 를 하고 content of file 로 hash 하면 different value from privious hash value in the index file 가 도출된다.<br/>
이전에 index file 에 저장되어있던 f2.txt 가 link 하고 있는 object link 가 다르다면 commit 할 것이 있다고 판단 할 수 있다.<br/>
<br/>
@<br/>
index 에있는.<br/>
33..25 f2.txt 의 object 내용과.<br/>
<br/>
가장 최신 commit 에서 tree 가 가르키는 object 안의 내용에 있는.<br/>
98..31 f2.txt.<br/>
의 내용이 다르다면 git 은 현재 최신의 f2.txt 은 add 명령어가 사용되어 index 가 수정되었고 commit 대기 상태 이다 라는 사실을 알 수가 있다.<br/>
<br/>
그리고 commit 이 이루어 지면 위에서 달랐던 file 들이 동일해지면서 commit 할게 없는 상태가 된다.<br/>
<br/>
@<br/>
code 를 작업하는 working directory 에서 add 를 하면 그 내용들이 .git folder 에 있는 index file 에 등록된다.<br/>
commit 을 하면 index file 에 등록된 내용이 objects 안에 저장된다.<br/>
      
@Chapter.<br/>
지옥에서 온 Git - branch 만들기.<br/>
<br/>
@<br/>
git init.<br/>
current directory 에 .git folder 를 포함하는 repository 가 create 된다.<br/>
<br/>
@<br/>
git commit -am "commit message"<br/>
자동으로 add commit 하는건데 한번도 add 하지 않은 file 에 이 command 를 적용하면 자동으로 add 가 되지 않는다.<br/>
<br/>
@<br/>
원래 code 를 변경하지 않으면서 client 를 위해 customizing 할때 branch 이 useful 하다.<br/>
<br/>
@<br/>
git branch : show list of branch.<br/>
* master : 현재 당신이 master 라는 branch 를 쓰고 있다.<br/>
git 을 사용하는 순간부터 default branch 를 사용하게 되어있는데 master 라고 불린다.<br/>
<br/>
@<br/>
git branch exp.<br/>
<br/>
@<br/>
git branch.<br/>
exp.<br/>
*master.<br/>
<br/>
current master 를 쓰고 있기때문에 * 가 master 앞에 있다.<br/>
<br/>
@<br/>
git checkout exp : exp branch 에 checkout 해서 들어간다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - branch 정보확인.<br/>
<br/>
@<br/>
git log --branches : 현재 checkout 되어있는 branch 뿐만아니라 repository 에 있는 모든 branch 를 보여준다.<br/>
<br/>
git log --branches --decorate.<br/>
(master) master branch 의 latest commit 을 표시한다.<br/>
<br/>
(HEAD -> exp).<br/>
exp 의 latest commit 이 4 임을 표시한다.<br/>
HEAD : exp branch 에 checkout 되어있다.<br/>
<br/>
q 를 눌러서 나간다.<br/>
<br/>
@<br/>
git log --branches --decorate --graph.<br/>
빨간색으로 줄이 생긴다.<br/>
효용은 master branch 에서 내용이 바뀔때 줄의 효용이 생긴다.<br/>
<br/>
@<br/>
git log : 현재 branch 의 log 만 보여준다.<br/>
git log --branches : 모든 branch 의 log 를 보여준다.<br/>
<br/>
@<br/>
master, exp 쭉 올라가보면 2를 담는 파일의 commit 을 만난다. 공통의 조상이다.<br/>
<br/>
@<br/>
git log --branches --decorate --graph --oneline.<br/>
한줄로 간결하게 전체적으로 branch 흐름을 보여준다.<br/>
<br/>
@<br/>
source tree 깔려있으면 current directory 에서 stree 를 run 하면 current directory 가 source tree 에서 나타난다.<br/>
<br/>
@<br/>
git log master..exp.<br/>
master 와 exp 의 차이가 뭐냐.<br/>
matter 에는 없고 exp 에 있는걸 보여준다.<br/>
<br/>
@<br/>
git log -p master..exp.<br/>
code 의 차이까지 보여준다.<br/>
<br/>
@<br/>
gid diff master..exp.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - branch 병합.<br/>
<br/>
@<br/>
master 에서 branch 했던 exp 를 작업을 하고 다시 master 로 merge 하는 방법.<br/>
먼저 master 로 checkout 을 한다.<br/>
그리고 git merge exp 를 한다.<br/>
merge message window 에서 :wq 한다.<br/>
<br/>
@<br/>
이제 master 는 두개의 parent commit 를 갖는다.<br/>
하나는 원래 master branch 의 latest commit.<br/>
또 하나는 exp branch 에서의 merge 하기 직전의 latest commit.<br/>
<br/>
@<br/>
master 에 있고 exp 에 없는 것을 가져오자.<br/>
git checkout exp.<br/>
git merge master.<br/>
<br/>
@<br/>
exp 를 지워도 된다.<br/>
git branch -d exp.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - branch 수련.<br/>
<br/>
@<br/>
branch.<br/>
fast forward branch.<br/>
not fast forward branch.<br/>
<br/>
@<br/>
issue 하나를 수정하기 위해 branch 를 만든다.<br/>
git checkout -b iss53.<br/>
다음 두 행을 -b 를 씀으로써 한번에 하는 명령어.<br/>
git branch iss53 : branch iss53 create.<br/>
git checkout iss53.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - stash.<br/>
<br/>
@<br/>
stash : 감추다, 숨겨두다.<br/>
branch 에서 작업을 하는 중에, 작업이 끝나지 않았는데, 다른 branch 로 checkout 해서 다른 작업을 해야할 때가 있을 수 있다.<br/>
<br/>
unfinished task 를 commit 하기 좀 그렇고, commit 을 안하면 checkout 할 수 없고 하는 문제가 생길 수 있다.<br/>
<br/>
이때, stash 를 쓰면 작업했던 내용을 어딘가에 숨겨놓을 수 있다.<br/>
<br/>
@<br/>
git init.<br/>
vim f1.txt.<br/>
git add f1.txt.<br/>
git commit -m 1.<br/>
<br/>
git chceckout - exp : branch create + checkout.<br/>
<br/>
exp branch 에서 f1 수정 중에서 git checkout master 하면 exp 에서 수정한 내용이 master branch 에도 영향을 준다.<br/>
<br/>
@<br/>
git stash (save).<br/>
saved working directory and index state WIP on exp : 91523e45 1.<br/>
<br/>
@<br/>
다시 살리는 방법.<br/>
git stash apply.<br/>
<br/>
@<br/>
stash list 보기.<br/>
git stash list.<br/>
<br/>
@<br/>
git reset --hard 를 해도.<br/>
git stash apply 를 하면 다시 살아난다.<br/>
stash list 는 explicit 하게 삭제 하지 않으면 항상 살아있다.<br/>
<br/>
@<br/>
stash list 가 복수개일때.<br/>
git stash apply 는 가장 위에 있는 최근 stash 를 적용한다.<br/>
<br/>
@<br/>
git stash drop 은 가장 latest stash 를 삭제한다.<br/>
<br/>
@<br/>
이렇게 latest stash 를 지운뒤.<br/>
git stash apply; git stash drop; 을 하면 한번에 할 수 있다.<br/>
<br/>
@<br/>
git stash 로 임시저장하고.<br/>
git stash apply; git stash drop; 으로 적용하고 삭제할수 있다.<br/>
한번에 하려면 git stash pop 을 쓴다.<br/>
<br/>
@<br/>
add 하지 않아서 tracked 되지 않고 있는 file 에 대해서는 stash 를 쓸 수 없다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - 원리 : branch.<br/>
<br/>
@<br/>
git init.<br/>
git folder 에 file 들이 생성된다.<br/>
HEAD file 의 내용 refs/heads/master 이 적혀있다.<br/>
<br/>
refs/heads/master file 은 아직 존재하지 않는 상태이다.<br/>
<br/>
@<br/>
vim f1.txt.<br/>
contents : a.<br/>
<br/>
git add f1.txt.<br/>
<br/>
git commit -m "1"<br/>
<br/>
go to gistory and you can see refs/heads/master.<br/>
내용은 object link 이다.<br/>
이걸 click 해보자.<br/>
<br/>
방금 commit 된 걸 가르키는 id 였다.<br/>
<br/>
@<br/>
vim f1.txt.<br/>
a, b.<br/>
<br/>
git commit -am "2"<br/>
<br/>
@<br/>
go to gistory.<br/>
refs/heads/master file 이 바뀌어있다.<br/>
<br/>
object link 를 click 해 보자.<br/>
그럼 이 object link 가 방금 commit 을 가리키고 있다는 걸 알수있다.<br/>
<br/>
@<br/>
summary.<br/>
folder .git 만들면 head file 생긴다.<br/>
head 는 master file 가르킨다.<br/>
master 는  latest commit 을 가리킨다.<br/>
<br/>
@<br/>
git log 를 했을때.<br/>
commit list 를 보여주는데 최신순으로 보여줄수 있는 이유가 git 이 head file 을 가지고 있기 때문이다.<br/>
<br/>
@<br/>
branch 는 refs directory 밑에 있는 file 을 의미한다고 볼 수 있다.<br/>
<br/>
@<br/>
git branch exp.<br/>
두개의 file 이 바뀌었다.<br/>
logs/refs/heads/exp.<br/>
refs/heads/exp.<br/>
<br/>
refs/heads/exp 이것을 살펴보자.<br/>
click 하면 latest object 를 pointing 하고 있다.<br/>
<br/>
@<br/>
rm .git/refs/heads/exp 하면 branch 가 삭제된다.<br/>
git branch 로 없어진것 확인 가능.<br/>
<br/>
@<br/>
vim .git/refs/heads/exp file 만들고 commit link 를 적어주면 exp branch 가 다시 생성된다.<br/>
<br/>
branch 는 중요하고 강력하지만 일반 text file 하나일 뿐이다.<br/>
<br/>
@<br/>
git checkout exp.<br/>
HEAD file 이 바뀌어있다.<br/>
refs/heads/exp 를 가리키고있다.<br/>
refs/heads/exp 은 commit 을 가리킨다.<br/>
<br/>
@<br/>
vim f2.txt.<br/>
a.<br/>
<br/>
git add f2.txt.<br/>
git commit -m "3"<br/>
<br/>
@<br/>
HEAD 는 refs/heads/exp 를 가리킨다.<br/>
refs/heads/exp 는 latest commit 인 3 을 가리킨다.<br/>
<br/>
@<br/>
git checkout master.<br/>
HEAD file 이 refs/heads/master 를 가리킨다.<br/>
refs/heads/master 는 latest commit 을 가리킨다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - branch 충돌해결.<br/>
<br/>
@<br/>
file 이 완전히 다르면 자동으로 합쳐진다.<br/>
<br/>
@<br/>
master, exp branch 에 각각 common.txt 를 만든다.<br/>
같은 부분을 수정해본다.<br/>
function b(){}.<br/>
function a(master){}.<br/>
function c(){}.<br/>
<br/>
function b(){}.<br/>
function a(exp){}.<br/>
function c(){}.<br/>
<br/>
git checkout master.<br/>
git merge exp.<br/>
<br/>
<br/>
function b(){}.<br/>
<<HEAD.<br/>
function a(master){}.<br/>
===.<br/>
function a(exp){}.<br/>
>>exp.<br/>
function c(){}.<br/>
<br/>
<<HEAD.<br/>
function a(master){}.<br/>
===.<br/>
에서 수정한 내용.<br/>
<br/>
function a(exp){}.<br/>
>>exp.<br/>
에서 수정한 내용.<br/>
<br/>
git 이 automerge 를 실패해했으니까 merge 를 manually process 하라고 conflict part 를 표시하면서 위임한다.<br/>
<br/>
<br/>
이런식으로 수정해본다.<br/>
function b(){}.<br/>
function a(master, exp){}.<br/>
function c(){}.<br/>
<br/>
:wq.<br/>
<br/>
git add common.txt.<br/>
git commit.<br/>
<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - 원리 : reset checkout.<br/>
<br/>
@<br/>
git reset --hard commit-hash-value.<br/>
commit-hash-value 로 latest commit 이 set 된다.<br/>
<br/>
refs/heads/master 가 수정된다.<br/>
checkout 한 branch 인 master 가 어떤 latest commit 을 가지고 있는가 를 가리키는 file 이다.<br/>
<br/>
@<br/>
reset 을 한다는 것은 checkout 하고 있는 branch 의 latest commit 을 바꾸는 행위라고 할 수 있다.<br/>
file 이 너무 많을 때 garbage collector 가 돌아가면서 file 을 정리하는 경우를 제외하고는 더 뒤의 commit 들은 지워지지는 않는다.<br/>
<br/>
@<br/>
reset 을 취소하고 싶을때는 ORIG_HEAD, logs/refs/heads/master 이다.<br/>
<br/>
@<br/>
ORIG_HEAD 안의 link 를 click 하면 reset 으로 삭제된 commit 을 가리키고있다.<br/>
<br/>
@<br/>
logs/refs/heads/master 를 보면 가장 밑에 내용이 xx1(reset 으로 삭제된 commit) xx2(reset 으로 latest commit 으로 된 commit) 이 xx3 가 되었다 가 적혀있다.<br/>
<br/>
Therefore, logs/refs/heads/master 는 master branch 에서 일어나는 important event 들을 record 해놓는 log 이다.<br/>
<br/>
@<br/>
정보를 잃어버릴 가능성이 있는 명령을 실행하기 전에 git 은 ORIG_HEAD 라는 곳에 현재 branch 의 latest commit 을 record 한다.<br/>
<br/>
따라서, reset 을 cancel 할 수 있다.<br/>
git reset --hard ORIG_HEAD.<br/>
<br/>
@<br/>
ORIG_HEAD 보다 더 좋은 방법은 logs/refs/heads/master 을 보는 것이다.<br/>
git reflog.<br/>
commit 들을 보여준다.<br/>
<br/>
@<br/>
git checkout commit-hash-value.<br/>
git branch.<br/>
* HEAD detached at 82kf.<br/>
master.<br/>
<br/>
gistory 를 보면 바뀐 file 은 HEAD file 하나이다.<br/>
우리가 봤던 HEAD 는 refs/heads/master file 을 가리켰다.<br/>
위의 HEAD 는 직접 commit link 를 가리킨다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - 원리 : working copy&index&repository.<br/>
<br/>
@<br/>
working directory(=working tree, working copy).<br/>
실제 작업이 진행되는 directory.<br/>
<br/>
index(=staging area, cache).<br/>
git add 를 했을 때 그것이 포함되는 곳.<br/>
<br/>
repository(=history, tree).<br/>
실제 version, commit 들이 저장되는 곳.<br/>
<br/>
git reset --hard : 3군데 다 초기화됨.<br/>
git reset --soft : repository 만 초기화됨.<br/>
git reset --mixed : index, repository 만 초기화됨.<br/>
<br/>
@<br/>
작업을 진행하다가 commit 하기전에 이 작업이 마음에 안들때 예전 상태로 돌아가고 싶을 때.<br/>
git reset --hard 를 쓰기도 한다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - 원리 : merge & conflict.<br/>
<br/>
@<br/>
git checkout -b exp : exp branch 만들면서 동시에 chceckout 까지 한다.<br/>
<br/>
master, exp branch 에서 같은 부분을 수정했다고 가정한다.<br/>
<br/>
in master, git merge exp : exp 것들 master 로 합친다.<br/>
그런데 conflict 되어 auto merge failed.<br/>
<br/>
@<br/>
go to gistory.<br/>
index file 을 보면.<br/>
xx1 1 f1.txt.<br/>
xx2 2 f1.txt.<br/>
xx3 3 f1.txt.<br/>
<br/>
이런식으로 conflict 가 occurred 하면 xx 뒤에 숫자가 붙는다.<br/>
각각을 click 해 본다.<br/>
1번인 f1.txt.<br/>
는 내용이 common 이다.<br/>
수정전에 공통으로 가지고 있었던 f1.txt 의 내용이다.<br/>
<br/>
xx2 2 f1.txt 를 click 해본다.<br/>
master 로 수정된 내용을 볼 수 있다.<br/>
<br/>
xx3 3 f1.txt 를 click 해본다.<br/>
병합이 될 대상인 exp 내용이 써져있다.<br/>
<br/>
이러한 3가지 정보를 바탕으로 3 way merge 라는 merge 가 이루어질 수 있다.<br/>
<br/>
@<br/>
MERGE_HEAD 를 click 해 본다.<br/>
merge 가 될 대상(exp) 의 latest commit 이다.<br/>
<br/>
@<br/>
MERGE_MSG 는 merge 를 하는 과정에서 conflict 가 발생했는데 commit 을 할 때 보여줄 message 이다.<br/>
<br/>
@<br/>
ORIG_HEAD 는 merge 는 위험한 작업이라서 그 이전으로 돌아가기 위한 일종의 back up 이다.<br/>
<br/>
@<br/>
objects/34/xx4 는 충돌이 일어난 내용을 설명하는 file 이다.<br/>
<br/>
@<br/>
merge 를 해주는 tool 이 있다.<br/>
여기서는 kdiff3 를 사용해본다.<br/>
<br/>
git config --global merge.tool kiff3 를 해서 merge command 를 했을 때 kdiff3 가 실행되도록 한다.<br/>
beyondcompare tool 을 쓴다면 git config --global merge.tool bc 를 하면 된다.<br/>
<br/>
@<br/>
git mergetool 은 conflict file 에 대해서 mergetool 을 이용해서 merge 하도록 git 에게 commnad 한다.<br/>
<br/>
@<br/>
kiff3 의 layout 은 다음과 같다.<br/>
4칸으로 구분됨.<br/>
왼쪽은 f1.txt(base) 이다.<br/>
가운데는 f1.txt(local) 이다.<br/>
오른쪽은 f1.txt(remote) 이다.<br/>
밑에는 output directory 이다.<br/>
<br/>
@<br/>
conflict 란 다음과 같다.<br/>
common parent commit 이 있다.<br/>
여기에서 master, exp branch 가 같은 곳을 수정하고 각각 commit 을 했다.<br/>
이 둘은 수정내용은 다르지만 common parent commit 이 있다는 것이고 이것을 base 라고 부른다.<br/>
local 은 checkout 되어 merge 되는 내용을 받는 쪽이다.<br/>
<br/>
A,B,C 를 누르면 각각 common, master, exp 가 채택되어 merge 된다.<br/>
동시에 누를수도있다.<br/>
다 누르면 common, master, exp 내용 전부다 merge 된다.<br/>
<br/>
master.exp 같은 내용으로 아래 칸에서 직접 수정할 수 도있다.<br/>
<br/>
그리고 저장한다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - 원리 : 3 way merge.<br/>
<br/>
@<br/>
2way merge : base 는 보지 않고 me, other 만 비교하여 merge 하는 방법이다.<br/>
3way merge : base 를 참고하여 me, other 을 merge 하는 방법이다.<br/>
<br/>
@<br/>
<table>
  <tr>
    <th>me</th>
    <th>other</th>
    <th>2way merge</th>
  </tr>
  <tr>
    <td>A</td>
    <td></td>
    <td>conflict</td>
  </tr>
  <tr>
    <td>B</td>
    <td>B</td>
    <td>B</td>
  </tr>
  <tr>
    <td>1</td>
    <td>2</td>
    <td>conflict</td>
  </tr>
  <tr>
    <td></td>
    <td>D</td>
    <td>conflict</td>
  </tr>
</table>
<br/>
1, 2 같이 다른 경우는 auto merge 할때 뭐가 맞는지 알 수 없다.<br/>
그래서 merger 에게 뭐가 맞는지 conflict 를 내야한다.<br/>
공백, D 경우 내용이 없는게 수정된 사항인지 있는게 수정된 사항인지 알 수 없다.<br/>
<br/>
@<br/>
<table>
  <tr>
    <th>me</th>
    <th>base</th>
    <th>other</th>
    <th>3way merge</th>
  </tr>
  <tr>
    <td>A</td>
    <td>A</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>B</td>
    <td>B</td>
    <td>B</td>
    <td>B</td>
  </tr>
  <tr>
    <td>1</td>
    <td>C</td>
    <td>2</td>
    <td>conflict</td>
  </tr>
  <tr>
    <td></td>
    <td>D</td>
    <td>D</td>
    <td></td>
  </tr>
</table>
<br/>
AA공백이면 me 는 수정하지 않았고 other 은 수정했다라는걸 알수있으므로 수정한것을 채택할 수 있다.<br/>
세명이 같으므로 B.<br/>
셋 모두 다르므로 conflict 를 낸다.<br/>
공백DD 이므로 수정된 사항이 있음을 인지하고 이를 반영한다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - 원격 저장소 소개.<br/>
<br/>
@<br/>
remote repository(ex, github, private common server), local repository.<br/>
<br/>
@<br/>
remote repository : backup, coworking.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - 원격 저장소 생성.<br/>
<br/>
@<br/>
git init --bare name-of-repository 은 작업은 할수없고 그냥 repository 역할만 할수 있는 option 이다.<br/>
remote repository 를 만들때 사용한다.<br/>
<br/>
@<br/>
git remote add address-of-remote-repository 는 local repository 와 remote repository 를 연결한다.<br/>
경로를 길게 쓰기 번거로우므로 origin 을 사용하면 주의의 alias 가 된다.<br/>
git remote add origin address-of-remote-repository.<br/>
<br/>
add 된 repository 를 지우고 싶으면 git remote remove origin 을 사용한다.<br/>
<br/>
@<br/>
현재 local repository 에서 master branch 상태이다.<br/>
git push 를 하면 master branch 의 내용을 remote repository 에 똑같은 이름의 branch 로 push 한다.<br/>
<br/>
push 방식(matching, simple 중에서)을 global 하게 설정하려면 git config --global push.default simple 을 사용한다.<br/>
<br/>
@<br/>
git push --set-upstream origin master 은 push 할때 origin 주소에 master branch 로 push 한다.<br/>
--set-upstream 을 써주면 앞으로 master branch 에서 push 를 하면 자동으로 origin 의 master 로 push 하도록 설정하는 것이다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - github 소개 (Github).<br/>
<br/>
@<br/>
clone 방법.<br/>
원하는 directory 로 이동한다.<br/>
git clone address-of-remote-repository 하면 folder 가 생성되면서 clone 된다.<br/>
혹은 git clone address-of-remote-repository folder-name 으로 folder 를 직접 만들면서 할 수 있다.<br/>
<br/>
@<br/>
clone 한 folder 에서 git log 하면 commit history 를 볼 수 있다.<br/>
<br/>
git log --reverse 를 하면 거꾸로 log 를 볼 수 있다.<br/>
<br/>
첫번째 commit 의 code 를 보려면 commit hash value 를 copy 하고 q 로 나가서 git checkout commit-hash-value 를 하면 된다.<br/>
그러면 current branch 가 이 commit 이 된다.<br/>
<br/>
그리고 ls -al 로 file 목록을 본다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - 원격 저장소 만들기 (Github).<br/>
<br/>
@<br/>
두가지 상황이 있을 수 있다.<br/>
<br/>
상황1 : remote repository 를 만들고 이것을 clone 해서 local repository 를 만들고 여기에서 작업을 하는 방식.<br/>
상황2 : local repository 에서 작업을 해왔다. 그리고 작업 내역을 remote repository 로 push 하고 싶을때.<br/>
<br/>
@<br/>
상황2부터 보자.<br/>
git remote add origin https://github.com/youngmtool/test.git.<br/>
현재 local repository 에 remote repository (origin https://github.com/youngmtool/test.git) 를 연결(add) 시킨다.<br/>
<br/>
@<br/>
git 은 여러개의 remote repository 를 하나의 local repository 에 연결시킬 수 있다.<br/>
loca repository 에서 작업한걸 A or B 등으로 마음대로 push 할 수 있다.<br/>
<br/>
기본 branch 의 alias 가 master 인 것 처럼, origin 은 local repository 와 연결되어 있는 가장 기본적인 remote repository 의 alias 로 사용된다.<br/>
<br/>
@<br/>
git 에서는 local repository 를 기준으로 얘기한다.<br/>
<br/>
내가 작업하는 local repository 에서 remote repository 로 작업을 보낼때 push 라고 표현한다.<br/>
<br/>
git push -u origin master 는 현재 checkout 되어있는 local repository 의 branch 의내용을 origin 에 해당하는 remote repository 의 master branch 에 push 한다는 의미이다.<br/>
<br/>
-u 는 한번만 쓰면 되는 option 으로서 local repository 의 branch 와 remote repository 의 master branch 를 서로 연결 시켜서 다음부터는 git push 만 쓰면 자동으로 위와 같이 push 되게 하는 option 이다.<br/>
<br/>
@<br/>
위의 방법은 작업하고 있던 local repository 를 remote repository 로 옮기는 방식이며 backup 의 의미를 갖는다.<br/>
<br/>
@<br/>
먼저 remote repository 에 자료가 있고 이걸 local repository 로 clone 방법은.<br/>
원하는 folder 로 이동한 뒤.<br/>
git clone address . 을 하면 되고, dot 을 써주면 현재 directory 를 가리킨다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - 동기화 방법 (Github).<br/>
<br/>
@<br/>
clone 을 git_home, git_office 두 군데에 해본다.<br/>
<br/>
git commit --amend 는 commit message 를 수정할 수 있다.<br/>
remote repository 에 올리기 전에만 하는게 좋다.<br/>
<br/>
@<br/>
git_home 에서 수정하고 remote repository 에 push 한다.<br/>
<br/>
@<br/>
git_office 에서 (local repository 입장에서) remote repository 에 있는 내용을 pull 을 한다.<br/>
<br/>
@Chapter.<br/>
지옥에서 온 Git - ssh를 이용해서 로그인없이 원격저장소 사용하기 (Github).<br/>
      
   </BODY>
</HTML>
